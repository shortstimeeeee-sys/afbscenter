# 대관 예약 체크인 및 횟수 처리 흐름

한글로 순서대로 정리한 설명입니다.

---

## 1. 이용권 횟수가 차감되는 시점 (언제 줄어드나)

횟수는 **아래 두 경우에만** 1회씩 차감됩니다.

1. **체크인할 때**  
   출석 체크인 API를 호출해서 체크인을 완료하면, 그 예약에 연결된 이용권에서 1회 차감됩니다.
2. **체크인된 예약을 복사해서 새 예약을 만들 때**  
   “체크인 완료된 예약”을 복사해서 새 예약을 등록하면, 복사 시점에 1회 차감됩니다.

**예약만 등록하거나 수정해서 저장하는 것만으로는 차감되지 않습니다.**  
저장만 했는데 잔여 횟수가 줄어든다면 버그입니다.

---

## 2. 대관 예약 체크인 시 처리 순서

체크인 버튼을 누르면 아래 순서대로 진행됩니다.

**1단계: 예약 조회**  
- 체크인 요청에 담긴 `bookingId`로 예약을 조회합니다.  
- 이 예약에 연결된 이용권(`memberProduct`)이 있으면, 그 이용권 ID로 DB에서 이용권을 한 번 더 조회합니다.  
- (lazy 로딩 이슈를 피하기 위해 이용권을 따로 조회합니다.)

**2단계: 이미 체크인된 예약인지 확인**  
- 이 예약으로 이미 출석(Attendance) 기록이 있는지 조회합니다.  
- **이미 있고**, 그 출석에 체크인 시각(`checkInTime`)이 있으면 → “이미 체크인된 예약입니다” 로 처리하고 끝냅니다.  
- **없거나**, 출석은 있지만 체크인 시각이 없으면 → 다음 단계로 갑니다.

**3단계: 출석(Attendance) 기록 준비**  
- 출석 기록이 없으면: 새 출석을 만들고, 예약·회원·시설·날짜를 넣습니다.  
- 출석 기록이 있으면: 그대로 씁니다.  
- 공통으로 **체크인 시각**을 “지금”으로 넣고, 상태를 “출석(PRESENT)”으로 둡니다.

**4단계: 대관 여부 확인**  
- 이 예약의 목적(`purpose`)이 **대관(RENTAL)** 인지 확인합니다.  
- 대관이 아니면 레슨용 로직으로, 대관이면 아래 5단계처럼 처리합니다.

**5단계: 대관일 때 이용권 1회 차감**  
- **예약에 이용권이 연결되어 있는지** 봅니다. 없으면 “대관 예약에 이용권이 연결되지 않음”으로 끝냅니다.  
- 연결되어 있으면:  
  - **이용권을 DB에서 다시 조회**해서, 최신 잔여(패키지면 `packageItemsRemaining` JSON, 아니면 `remainingCount`)를 기준으로 합니다.  
  - **횟수 1회 차감**을 수행합니다 (아래 3장 참고).  
  - 차감에 성공하면:  
    - **차감 기록(DEDUCT)** 을 이용권 히스토리(`MemberProductHistory`)에 1건 저장합니다.  
    - “차감 전 잔여”와 “차감 후 잔여”를 응답용으로 따로 담아 둡니다.

**6단계: 출석 저장**  
- 위에서 만든/수정한 출석(Attendance)을 DB에 저장합니다.

**7단계: 화면에 보낼 응답 만들기**  
- 체크인 시각, 완료 메시지 등을 넣고,  
- 5단계에서 차감했으면 **이용권 이름, 차감 전 잔여, 차감 후 잔여, 총 횟수**를 응답에 넣습니다.  
- 프론트에서는 이 값을 그대로 “체크인 완료” 창에 “차감 전: N회 / 차감 후: M회 / 총 횟수: T회” 로 띄웁니다.

---

## 3. 횟수 차감이 실제로 어떻게 되는지 (대관 10회권 같은 패키지)

대관 10회권처럼 **패키지**(`packageItemsRemaining` JSON이 있는 이용권)인 경우 순서는 아래와 같습니다.

**1단계: 패키지 여부 확인**  
- 이용권에 `packageItemsRemaining` 값이 있고 비어 있지 않으면 “패키지”로 판단합니다.

**2단계: JSON에서 차감할 항목 정하기**  
- `packageItemsRemaining`은 JSON 배열입니다.  
- 대관은 “레슨 이름”이 비어 있는 경우이므로:  
  - 이름에 **“대관”** 이 들어간 항목을 찾거나,  
  - 그런 게 없으면 **잔여가 0보다 큰 첫 번째 항목**을 찾습니다.  
- 그 항목의 `remaining` 값을 1 줄입니다 (예: 3 → 2).

**3단계: JSON과 DB 잔여 맞추기**  
- 수정한 JSON 전체를 다시 이용권에 저장합니다.  
- JSON 안의 모든 항목 `remaining` 을 더한 값을 구해서, 이용권의 **전체 잔여(`remainingCount`)** 로 저장합니다.  
- 모든 항목 잔여가 0이면 이용권 상태를 “소진(USED_UP)”으로 바꿉니다.

**4단계: 차감 전/후 값 정하기**  
- **차감 전**: 위에서 1 줄이기 **전** 그 항목의 `remaining` 값 (또는 같은 의미로 계산한 값).  
- **차감 후**: 1 줄인 뒤의 잔여.  
- 이 “차감 전”이 체크인 완료 메시지의 **“차감 전: N회”** 에 쓰이고, “차감 후”가 **“차감 후: M회”** 에 쓰입니다.

**5단계: DEDUCT 히스토리 저장**  
- 이용권 히스토리에 **차감(DEDUCT)** 1건을 남깁니다.  
- “변경량 -1”, “차감 후 잔여” 를 넣어 두고, 나중에 목록/예약 수정 화면에서 “실제로 몇 번 썼는지”를 셀 때 이걸 사용합니다.

---

## 4. 화면에 “잔여 N회”가 나오는 방식

**회원별 이용권 목록**, **예약 수정(빠른 예약 수정)** 등에서는 “잔여”를 아래처럼 맞춥니다.

- 시스템이 **이용권별로 “차감(DEDUCT) 기록이 몇 건인지**를 셉니다.  
- **표시할 잔여 = 총 횟수 − DEDUCT 건수** 로 계산한 값과, DB/JSON에 저장된 잔여 중 **더 작은 쪽**을 사용합니다.  
- 그래서 예전에 “조정”으로 DB만 바꿔서 숫자가 어긋나 있어도, “실제로 차감한 만큼만 남은 것”으로 보이게 합니다.

반면 **체크인 완료 메시지의 “차감 전 / 차감 후”** 는:

- **그 순간 DB(또는 패키지면 JSON)에 있던 잔여**를 “차감 전”으로 쓰고,  
- 1회 뺀 값을 “차감 후”로 씁니다.  
- DEDUCT 히스토리로 다시 계산한 값이 아니라, **당시 DB/JSON 값**을 그대로 쓰기 때문에, 목록에 보이는 잔여와 다르게 나올 수 있습니다.

---

## 5. 정리 (순서 요약)

1. **차감이 일어나는 때**: (1) 체크인할 때, (2) 체크인된 예약을 복사해서 새 예약 만들 때.  
2. **체크인 시 순서**: 예약 조회 → 출석 확인/생성 → 대관이면 예약에 연결된 이용권으로 1회 차감 → DEDUCT 1건 저장 → 출석 저장 → 응답(차감 전/후 등) 반환.  
3. **패키지 차감 순서**: JSON에서 대관(또는 잔여 있는 첫 항목) 항목의 잔여 1 감소 → JSON·DB 잔여 갱신 → 차감 전/후 계산 → DEDUCT 히스토리 저장.  
4. **화면 잔여**: 목록/예약 수정은 “총 횟수 − DEDUCT 건수” 기준으로 상한을 걸어서 표시하고, 체크인 완료 메시지는 당시 DB/JSON 값을 그대로 “차감 전/차감 후”로 표시합니다.

이렇게 순서대로 동작하도록 되어 있습니다.
